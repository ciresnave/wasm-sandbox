# WebAssembly Component Model Support

The WebAssembly Component Model represents the next evolution of WebAssembly, focusing on better language interoperability and more complex application structures with type-safe interfaces.

## Overview

The Component Model allows for:

- **Interface-driven development** with WIT (WebAssembly Interface Type) definitions
- **Multi-language component authoring** with consistent interfaces
- **Structured data exchange** without manual serialization/deserialization
- **Explicit imports and exports** with proper type checking
- **Composition of components** into larger applications

## Getting Started

### Creating a Component Runtime

```rust
use wasm_sandbox::runtime::component::ComponentRuntime;
use wasm_sandbox::security::{Capabilities, ResourceLimits};

// Create a ComponentRuntime with default security settings
let runtime = ComponentRuntime::new(
    Capabilities::minimal(),  // Use minimal capabilities for security
    ResourceLimits::default()
)?;
```

### Loading a Component

```rust
// Load from file
let component = runtime.create_component_module_from_file("path/to/component.wasm")?;

// Or from bytes
let wasm_bytes = std::fs::read("path/to/component.wasm")?;
let component = runtime.create_component_module(&wasm_bytes)?;
```

### Creating an Instance

```rust
// Create a store and linker
let mut store = runtime.create_store(());
let mut linker = runtime.create_linker::<()>();

// Instantiate the component
let instance = ComponentInstance::new(
    &component,
    store,
    &linker,
    Capabilities::default(),
    ResourceLimits::default()
)?;
```

## Working with WIT

The Component Model uses WIT (WebAssembly Interface Type) definitions to describe interfaces. Here's an example WIT definition:

```wit
package example:greeter;

interface greet {
    // Say hello to someone
    hello: func(name: string) -> string;
    
    // Get the current greeting
    get-greeting: func() -> string;
    
    // Set a custom greeting
    set-greeting: func(greeting: string);
}

world greeter {
    export greet;
}
```

## Integration with wit-bindgen

The `wasm-sandbox` library integrates with `wit-bindgen` to generate type-safe bindings for your components:

```rust
// Generated by wit-bindgen
use example_greeter::greet::*;

// Use the generated bindings with your component instance
let greeter = Greet::new(&mut store, &instance)?;
let result = greeter.hello(&mut store, "World")?;
println!("Result: {}", result);  // Output: "Hello, World!"
```

## Advanced Features

### Composing Components

```rust
// Load multiple components
let component_a = runtime.create_component_module_from_file("component_a.wasm")?;
let component_b = runtime.create_component_module_from_file("component_b.wasm")?;

// Create a composite component
// (This API is still evolving with the Component Model)
```

### Resource Controls

Components benefit from the same resource control mechanisms as traditional WebAssembly modules:

```rust
let memory_limits = MemoryLimits {
    max_memory_pages: 100,  // 6.4MB (1 page = 64KB)
    reserved_memory_pages: 1,
    max_growth_rate: Some(10),  // Max 10 pages/s growth
};

let resource_limits = ResourceLimits {
    memory: memory_limits,
    cpu: CpuLimits::default(),
    io: IoLimits::default(),
    time: TimeLimits::default(),
};

let instance = ComponentInstance::new(
    &component,
    store,
    &linker,
    Capabilities::minimal(),
    resource_limits
)?;
```

## Performance Considerations

- Component Model operations may have slightly higher overhead than raw WebAssembly modules
- Serialization/deserialization is handled automatically with proper type checking
- Memory management is more structured and safer

## Future Directions

As the WebAssembly Component Model evolves, the `wasm-sandbox` library will continue to enhance its support with:

- Improved component composition
- Advanced linking capabilities
- Better integration with language-specific toolchains
- Support for WASI preview2 via the Component Model
